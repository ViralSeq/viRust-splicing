---
title: "HIV Splicing Assay Report"
author: "Shuntai Zhou and Michael Clark @UNC-CH"
format:
  html:
    toc: true              # enable table of contents
    toc-location: left     # or "right"
    toc-float: true        # make TOC floating
    number-sections: true  # optional, for numbered headings
    code-fold: false       # don’t allow toggling
    code-summary: none
    code-line-numbers: false
    code-tools: false
    code-copy: false
    code-block-bg: false
    code-block-border-left: false
    theme: Superhero           # Superhero for dark theme. Materia or Cerualean for bright theme.
    smooth-scroll: true
    self-contained: true
    embed-resources: true
    fig-width: 8
    fig-height: 6
execute:
  echo: false              # hide all code by default
  warning: false
  message: false
params:
  version: "0.2.0"
  assay_type: "random-reverse"
  strain: "nl43"
  mismatch: 1
  file1: "nl43_r1.fastq.gz"
  file2: "nl43_r2.fastq.gz"
  summary_data_file: "output_summary.csv"
  splice_isoform_csv: "spliceforms_short.csv"
---

```{r setup, include=FALSE}
# allows the interactive shell has the same behavior as rendering
if (interactive()) {
  setwd(here::here("tests", "quarto"))  # or dirname(rstudioapi::getActiveDocumentContext()$path)
}
```

```{r}
library(tidyverse)
library(patchwork)
library(arsenal)
library(finalfit)
library(ggsci)
library(reticulate)
library(ggalluvial)
library(ggrepel)
library(ggnewscale)
library(scico)
library(jsonlite)
theme_set(theme_bw())
```


```{r}
if (!py_module_available("pandas")) {
  py_install("pandas")
} else {message("pandas installed")}

if (!py_module_available("plotly")) {
  py_install("plotly")
} else {message("plotly installed")}

```


```{r}

rustapp_version = params$version
assay_type =  params$assay_type
strain = params$strain
mismatch = params$mismatch
file1 = params$file1
file2 = params$file2
summary_data_path = params$summary_data_file
splice_isoform_csv = params$splice_isoform_csv

assay_type <- assay_type %>% toupper()
strain <- strain %>% toupper()
```



```{r}
# Read data

data <- read_csv(summary_data_path)

data <- data  %>%
  mutate(
    main_acceptor_after_d1 = case_when(
      str_detect(splice_category_2, "D1_A1") ~ "A1",
      str_detect(splice_category_2, "D1_A2") ~ "A2",
      str_detect(splice_category_2, "D1_A3") ~ "A3",
      str_detect(splice_category_2, "D1_A4") ~ "A4",
      str_detect(splice_category_2, "D1_A5") ~ "A5",
      str_detect(splice_category_2, "D1_A7") ~ "A7"
    ),
    main_acceptor_after_d1 = ifelse(spliced == "unspliced", "unspliced", main_acceptor_after_d1),
    main_acceptor_after_d1 = ff_label(main_acceptor_after_d1, "Main Acceptor After D1")
  )

# define alternative D1

list_GC_1 <- c("GCTGAAGCGCGCACG") # use GC after DIS
list_GC_2 <- c("CGCGCACGGCAAGAG") # use GC 5 base down first GC

list_GT_gag_AUG <- c("GAAGGAGAGAGATGG")

list_GT_gag_down <- c("GGTGCGAGAGCGTCG")

data <- data %>%
  mutate(
    D1_type_revised = ifelse((spliced == "spliced" & D1_type != "Alternative D1"), D1_type, NA)
  ) %>%
  mutate(
    D1_type_revised = case_when(
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_1)) ~ "GC 3 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_2)) ~ "GC 10 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_AUG)) ~ "GU downstream gag AUG",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_down)) ~ "GU further downstream in gag",
      (spliced == "spliced" & alternative_d1_used_common != "None") ~ "Others",
      T ~ D1_type_revised
    ),
  )
```


```{r}
# Here we merge the splice isoform information with the data
splice_form_data <- read_csv(splice_isoform_csv)
data <- data %>%
  left_join(splice_form_data, by = c("splice_category_2" = "SpliceForm"))

data = data %>% mutate(
    splice_cat2  = splice_cat2 %>%  ff_label("Splice isoforms (Shortened)"),
    splice_category_2 = splice_category_2 %>%  ff_label("Splice isoforms (Extended)")
  )

```

Report generated on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Run settings

::: {.callout-important}
**Assay type:** `r assay_type`

**Reference type:** `r strain`

**Mismatch allowed:** `r mismatch`

**viRust-splicing app version:** `r rustapp_version`
:::

**Input File 1 path:** `r file1`

**Input File 2 path:** `r file2`

---

::: {.callout-note}
**Output Files:**

  1. ***TSV file:*** Splice isoform analysis for each sequence, one record per sequence. NOTE: sequences with low qualities are removed.

  2. ***CSF file:*** Summarized splice isoform analysis. One record per UMI family. NOTE: UMI family size less than 3 are not shown.

  3. ***HTML file:*** Splice isoform analysis and visualization.

:::

::: {.callout-tip}

This report can be generated again by running:

```bash
quarto render report.qmd --execute-params quarto_params.json
```

**DO NOT** render directly with report.qmd, params are required to properly process data.

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Overal Spliced vs. Unpliced

### Summary table

```{r, results = 'asis'}
data  %>%
  mutate(spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown")))%>%
  tableby(~ spliced, data = .)  %>% summary()
```


### Percent spliced
```{r}
data %>%
  count(spliced, sort = TRUE)  %>%
  mutate(
    percent = 100 * n/ sum(n),
    spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown"))
  )  %>%
  ggplot(aes(x = 2, y = percent, fill = spliced)) +
  geom_col(color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = round(percent, 1)),
            position = position_stack(vjust = 0.5),
            color = "white") +
  scale_fill_nejm(name = "") +
  xlim(0.5, 2.5) +
  theme_void() +
  labs(title = "Percent Spliced",
       subtitle = "Including unknown") -> p1


data %>%
  count(spliced, sort = TRUE) %>%
  filter(spliced != "unknown") %>%
  mutate(
    percent = 100 * n/ sum(n),
    spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown"))
  )  %>%
  ggplot(aes(x = 2, y = percent, fill = spliced)) +
  geom_col(color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = round(percent, 1)),
            position = position_stack(vjust = 0.5),
            color = "white") +
  scale_fill_nejm() +
  xlim(0.5, 2.5) +
  theme_void() +
  labs(title = "Percent Spliced",
       subtitle = "Excluding unknown") -> p2

p1 + p2 + theme(legend.position = "none")
```


::: {.callout-caution}
Unknown splice types can come from mismatches (sequencing errors), unrecognized patterns or non-HIV sequences. If greater than 5%, please check the raw TSV file for details.
:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## D1 types

```{r, results = 'asis'}
# get main donor after D1

data <- data %>%
  mutate(
    main_acceptor_after_d1 = case_when(
      str_detect(splice_category_2, "D1_A1") ~ "A1",
      str_detect(splice_category_2, "D1_A2") ~ "A2",
      str_detect(splice_category_2, "D1_A3") ~ "A3",
      str_detect(splice_category_2, "D1_A4") ~ "A4",
      str_detect(splice_category_2, "D1_A5") ~ "A5",
      str_detect(splice_category_2, "D1_A7") ~ "A7"
    ),
    main_acceptor_after_d1 = ifelse(spliced == "unspliced", "unspliced", main_acceptor_after_d1),
    main_acceptor_after_d1 = ff_label(main_acceptor_after_d1, "Main Acceptor After D1")
  )

# define alternative D1

list_GC_1 <- c("GCTGAAGCGCGCACG") # use GC after DIS
list_GC_2 <- c("CGCGCACGGCAAGAG") # use GC 5 base down first GC

list_GT_gag_AUG <- c("GAAGGAGAGAGATGG")

list_GT_gag_down <- c("GGTGCGAGAGCGTCG")

data <- data %>%
  mutate(
    D1_type_revised = ifelse((spliced == "spliced" & D1_type != "Alternative D1"), D1_type, NA)
  ) %>%
  mutate(
    D1_type_revised = case_when(
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_1)) ~ "GC 3 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_2)) ~ "GC 10 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_AUG)) ~ "GU downstream gag AUG",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_down)) ~ "GU further downstream in gag",
      (spliced == "spliced" & alternative_d1_used_common != "None") ~ "Others",
      T ~ D1_type_revised
    ),
    D1_type = ff_label(D1_type, "D1 types"),
    final_des = factor(final_des, levels = c("A3", "A4", "A5", "A7", "vif", "vpr", "Incomplete")),
    final_des = ff_label(final_des, "Final Destinations"),
    D1_type_revised = factor(
      D1_type_revised,
      levels = c(
        "GC 3 base downstream of DIS",
        "GC 10 base downstream of DIS",
        "D1",
        "D1prime",
        "GU downstream gag AUG",
        "GU further downstream in gag",
        "Others"
      )
    ),
    D1_type_revised = ff_label(D1_type_revised, "Detailed D1 types"),
  )



# for inspections
data %>% filter( spliced == "spliced" ) %>%
  tableby(~ D1_type, data = .) %>% summary(title = "D1 Type of splice isoforms")

data %>% filter( spliced == "spliced" ) %>%
  tableby(~ D1_type_revised, data = .) %>% summary(title = "D1 Type of splice isoforms (detailed types)")
```

<div style="margin-top: 4em;"></div>

```{r}
data %>% filter(
  spliced == "spliced"
) %>%
  count(D1_type_revised) %>%
  mutate(percent_d1_type = 100 * n/sum(n)) %>%
  ggplot(aes(x = D1_type_revised, y = percent_d1_type, fill = D1_type_revised)) +
  geom_col() +
  scale_fill_nejm(name = "D1 types") +
    labs(y = "Percentage", x = "Type of D1", title =
         "Types of D1 used") +
  scale_y_continuous(limits = c(0,110)) +
  theme(axis.text = element_blank()) +
  geom_text(aes(label = paste0(round(percent_d1_type), "%")), size = 3, vjust = -0.5)

```

::: {.callout-caution}

**Source of "Others" in D1 types:**

* Mismatched alternative D1

* Mismatched upstream acceptor sequences

* Potential PCR bias (PCR primer matching acceptor sequences)

* Other alternative D1 sites.

**If substantial amount of "Other D1" is observed, refer to TSV file for details.**

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splice Isoforms

### Splice Isoforms by Major D1 types

```{r, results = "asis"}
data %>% tableby( D1_type ~ splice_cat2 , data = .) %>% summary(
  title = "Splice isoforms by major D1 types"
)
```


### Splice Isoforms by Detailed D1 types
```{r, results = 'asis'}
data %>% tableby( D1_type_revised ~ splice_cat2 , data = .) %>% summary(
  title = "Splice isoforms by detailed D1 types"
)
```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Acceptors After D1

### By Major D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type ~ main_acceptor_after_d1 , data = .) %>% summary(
  title = "Acceptor After D1 by major D1 types"
)
```

<div style="margin-top: 4em;"></div>

```{r}
data %>%
  filter(spliced == "spliced") %>%
  ggplot(
    aes(x = D1_type, fill = main_acceptor_after_d1)
  ) +
  geom_bar(position = "fill") +
  scale_fill_nejm(name = "Main Acceptor\nAfter D1") +
  labs(y = "Proportion",
       x = "D1 types")

```

### By Detailed D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type_revised ~ main_acceptor_after_d1 , data = .) %>% summary(
  title = "Acceptor After D1 by detailed D1 types"
)
```

<div style="margin-top: 4em;"></div>

```{r}
data %>%
  filter(spliced == "spliced") %>%
  ggplot(
    aes(x = D1_type_revised, fill = main_acceptor_after_d1)
  ) +
  geom_bar(position = "fill") +
  scale_fill_nejm(name = "Main Acceptor\nAfter D1") +
  labs(y = "Proportion", x = "D1 types") +
  theme(axis.text.x = element_text(angle = 90))

```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Final Destination Summary

### By Major D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type ~ final_des , data = .) %>% summary(
  title = "Final desitinations by major D1 types"
)
```

<div style="margin-top: 4em;"></div>

### By Detailed D1 types

```{r, results = 'asis'}
data %>% tableby( D1_type_revised ~ final_des , data = .) %>% summary(
  title = "Final desitinations by detailed D1 types"
)
```


<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>


## Final Destinations by splice flows

::: {.callout-note}
"Others" in D1 type are excluded in this analysis.
:::

```{r}
summarize_splice_flow <- function(des) {
  final_des_data <- data %>% filter(
    spliced == "spliced",
    final_des == des,
    D1_type_revised != "Others"
  )

  header <- paste0("### ", des, "\n\n")

  if (nrow(final_des_data) == 0) {
    # Callout warning box
    warning_block <- paste0(
      "::: {.callout-warning}\n",
      "**Warning:** Final destination ", des, " has 0 reads.\n",
      ":::",
      "\n\n"
    )
    return(paste0(header, warning_block))
  } else {
    res <- tableby(~ splice_cat2, data = final_des_data)
    body <- paste(capture.output(print(summary(res), output = "markdown")), collapse = "\n")
    body <- paste0(body, "\n\n")
    return(paste0(header, body))
  }
}
```

```{r, results='asis'}
for (des in c("A3", "A4", "A5", "A7", "vif", "vpr")) {
  cat(summarize_splice_flow(des))
}
```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>


## Splicing Events Cascade Plots

### Splicing cascade alluvial plot

```{r}
df_alluvium <- data %>% group_by(splice_cat2) %>%
  mutate(splice_category_count = n())

df_alluvium %>% filter(
  splice_cat2 != "Incomplete",
  splice_cat2 != "Unspliced") %>%
  select(c(15:26)) %>% select(-final_des, -step8c) %>% unique() -> df_alluvium_short

n <- df_alluvium_short$splice_category_count %>% sum()
cut_off_to_show = n * 0.03
df_alluvium_transformed <- df_alluvium_short %>% pivot_longer(cols = 1:8, names_to = "Steps")
# df_alluvium_transformed %>% write_csv("cascade_data.csv")
df_alluvium_transformed %>%
  ggplot(aes(x = Steps,
             stratum = value,
             alluvium = splice_cat2,
             y = splice_category_count,
             label = value)) +
  geom_flow(aes(fill = splice_cat2), stat="alluvium", lode.guidance="forward", alpha=0.6) +
  new_scale_fill() +
  geom_stratum(data = subset(df_alluvium_transformed, !is.na(value)),
             aes(fill=value), color = "black") +
  geom_text(stat = "stratum",
            size = 2) +
            #aes(label = ifelse(..count.. > cut_off_to_show, as.character(stratum), ""))) +
  theme_bw() + theme(legend.position = "none") +
  labs(
    x = "",
    y = "UMI count"
  )


```


### Splicing cascade Sankey plot

```{python}
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px

# Load data
# df = pd.read_csv("cascade_data.csv").dropna(subset=["value"])
df = r.df_alluvium_transformed.dropna(subset=["value"])
# Build node list
nodes = list(df["value"].unique())
node_index = {ev:i for i,ev in enumerate(nodes)}

# Assign isoform colors
isoforms = df["splice_cat2"].unique()
palette = px.colors.qualitative.Set3
if len(isoforms) > len(palette):
    palette = palette * ((len(isoforms) // len(palette)) + 1)
colors = {iso: palette[i] for i, iso in enumerate(isoforms)}

# Build links with hover labels
sources, targets, values, link_labels, link_colors = [], [], [], [], []
for isoform, group in df.groupby("splice_cat2"):
    group = group.sort_values("Steps")
    events = group["value"].tolist()
    count = group["splice_category_count"].iloc[0]
    for i in range(len(events)-1):
        sources.append(node_index[events[i]])
        targets.append(node_index[events[i+1]])
        values.append(count)
        link_labels.append(f"Isoform: {isoform}<br>Count: {count}")
        link_colors.append(colors[isoform])

fig = go.Figure(go.Sankey(
    arrangement="snap",
    node=dict(label=nodes, pad=15, thickness=20),
    link=dict(
        source=sources,
        target=targets,
        value=values,
        color=link_colors,
        label=link_labels,
        hovertemplate="%{label}<extra></extra>"
    )
))

fig.update_layout(
    title_text="HIV Splicing Isoform Sankey (hover to see isoform + count)",
    font_size=12
)
```


<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splice Cascade Analysis

### Events after A1

Summarize the percent unspliced after A1 which is vif in the total reads that reach A1

```{r, results = 'asis'}
data %>% filter(
  spliced == "spliced",
  main_acceptor_after_d1 == "A1"
) %>% mutate(
  A1_fate = case_when(
    splice_category_2 %>% str_detect("D2_unknown") ~ "Sequence after D2/D2b unrecognized",
    splice_category_2 %>% str_detect("noD2b") ~ "Incomplete",
    splice_category_2 %>% str_detect("D2b_unknown") ~ "Sequence after D2/D2b unrecognized",
    splice_category_2 %>% str_detect("noD2") ~ "Incomplete",
    splice_category_2 %>% str_detect("D2b-unspliced") ~ "No splicing after A1/vif",
    TRUE ~ "Spliced at D2/D2b"
  ),
  A1_fate = factor(
    A1_fate,
    levels = c("Spliced at D2/D2b",
               "No splicing after A1/vif",
               "Incomplete",
               "Sequence after D2/D2b unrecognized")),
  A1_fate = A1_fate %>% ff_label("Splice Events After A1")
) -> data_A1

data_A1 %>% tableby(~ A1_fate, data = .) %>% summary()
```

::: {.callout-tip}

The category ***"Sequence after D2/D2b unrecognized"*** comes from:

1. mismatches due to sequencing error/quality drop.

2. other patterns.

3. short sequences.

:::

<div style="margin-top: 4em;"></div>

### Events after A2

Summarize the percent unspliced after A2 which is vif in the total reads that reach A2

**Splice outcomes at A2 by Upstream Acceptor**

```{r, results = 'asis'}
reach_A2 <- c(
  "D2_A2",
  "D2b_A2",
  "D1_A2"
) %>% paste(collapse = "|")

A2_incomplete <- c(
  "noD3",
  "D3_unknown"
) %>% paste(collapse = "|")

data %>% filter(
  spliced == "spliced",
  splice_category_2 %>% str_detect(reach_A2)
) %>% mutate(
  A2_fate = case_when(
    splice_category_2 %>% str_detect("noD3") ~ "Incomplete",
    splice_category_2 %>% str_detect("D3_unknown") ~ "Sequence after D3 too short/unrecognized",
    splice_category_2 %>% str_detect("D3-unspliced") ~ "No splicing after A2/vpr",
    TRUE ~ "Spliced at D3",
  ),
  A2_fate = factor(
    A2_fate,
    levels = c("Spliced at D3",
               "No splicing after A2/vpr",
               "Incomplete",
               "Sequence after D3 too short/unrecognized")),
  A2_fate = A2_fate %>% ff_label("Splice Events After A2")
) -> data_A2

data_A2 %>% mutate(
  upstream_event = ifelse(main_acceptor_after_d1 == "A1", "D1->A1->A2", "D1->A2")) %>%
  tableby(upstream_event ~ A2_fate, data = .) %>% summary()
```

::: {.callout-tip}

The category ***"Sequence after D3 too short/unrecognized" ***comes from:

1. mismatches due to sequencing error/quality drop.

2. short sequences, often in Random-Reverse assay.

It is possible the ***Incomplete*** group can also come from short reads in Random-Reverse assay.

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splice Map (TBD)

Generate JSON string named "link", which can be used in JavaScript directly
```{r, echo=FALSE, results='asis'}
spliced_data = data %>% filter(spliced == "spliced") %>% count(splice_category_2)
total_spliced = spliced_data$n %>% sum()

splice_step_list = tibble(
  from = character(),
  to = character(),
  w = integer()
)

splice_step_list <- pmap_dfr(spliced_data, function(splice_category_2, n) {
  first_des <- substring(splice_category_2, 4, 5)
  return_tibble <- tibble(
    from = "D1",
    to = first_des,
    w = n
  )
  d2_pattern <- "D2b?_(A[0-9]+)"
  if (splice_category_2 %>% str_detect(d2_pattern)) {
    new_row <- tibble(
      from = "D2", to = str_match(splice_category_2, d2_pattern)[, 2], w = n
      )
    return_tibble <- return_tibble %>% bind_rows(new_row)
  }

  d3_pattern <- "D3_(A[0-9]+)"
  if (splice_category_2 %>% str_detect(d3_pattern)) {
    new_row <- tibble(
      from = "D3", to = str_match(splice_category_2, d3_pattern)[, 2], w = n
      )
    return_tibble <- return_tibble %>% bind_rows(new_row)
  }
  return(return_tibble)
})

link <- splice_step_list %>%
  group_by(from, to) %>%
  mutate(total = sum(w)) %>%
  ungroup() %>% select(-w) %>% unique() %>%
  mutate(w = total,
         total_spliced = total_spliced,
         percent = round(100 * w/total_spliced, 1)) %>%
  select(-total, -total_spliced) %>% arrange(from, to)

link <- toJSON(link, dataframe = "rows", auto_unbox=TRUE)
cat(sprintf('<script>window.links = %s;</script>', link))
```

```{=html}
<style>
  #splice_map{max-width:1200px;margin:18px auto;padding:0 16px;}
  #splice_map .board{position:relative;background:var(--panel);border:1px solid #23314a;border-radius:14px;overflow:hidden;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  #splice_map svg{width:100%;height:680px;display:block}
  #splice_map .axis line,.axis path{stroke:#cdd3e1}
  #splice_map .tick text{fill:#cdd3e1;font-size:12px}
  #splice_map .row-label{fill:#cdd3e1;font-size:12px;dominant-baseline:middle}
  #splice_map .feat rect{rx:6; ry:6; stroke:#1a2236; stroke-width:1}
  #splice_map .feat text{font-size:12px; fill:#0b1220; font-weight:600; paint-order:stroke; stroke:#ffffff; stroke-width:3px}
  #splice_map .link{fill:none;stroke-opacity:.35;pointer-events:stroke}
  #splice_map .link:hover{stroke-opacity:.9}
  #splice_map .arc-label{font:13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; fill:#0b1220; paint-order:stroke; stroke:#ffffff; stroke-width:3px; pointer-events:none;}
  #splice_map .board, #splice_map svg { overscroll-behavior: contain; }
</style>
</head>
<body>
<div id="splice_map" class="wrap">
  <div class="board">
    <svg id="stage"></svg>
  </div>
</div>

<script src="https://unpkg.com/d3@7"></script>
<script>
(function(){
  // ========= DATA ===========================================================
  const GENOME_MAX = 9719;

  const rowLabels = {
    1: "ORF1",
    2: "ORF2",
    3: "ORF3",
    4: "LTRs"
  };

  // test comment

  const C = {
    gag:"#6aa0e6", pol:"#d63b3b", env:"#f4be12",
    sub:"#6aa0e6", access:"#94c973", ltr:"#aaaaaa"
  };

  const features = [
    // row 1 — major genes
    { row:1, name:"Gag", start: 790,  end: 2292, color:C.gag },
    { row:1, name:"Pol", start: 2085, end: 5096, color:C.pol },
    { row:1, name:"Env", start: 6225, end: 8795, color:C.env },

    // row 2 — gag subunits
    { row:2, name:"MA",  start: 790,  end: 1185, color:C.sub },
    { row:2, name:"CA",  start: 1187, end: 1878, color:C.sub },
    { row:2, name:"p2",  start: 1879, end: 1974, color:C.sub },
    { row:2, name:"NC",  start: 1975, end: 2199, color:C.sub },
    { row:2, name:"p1",  start: 2200, end: 2254, color:C.sub },
    { row:2, name:"p6",  start: 2253, end: 2292, color:C.sub },

    // row 3 — accessory/regulatory (simplified spans)
    { row:3, name:"vif", start: 5041, end: 5619, color:C.access },
    { row:3, name:"vpr", start: 5559, end: 5850, color:C.access },
    { row:3, name:"vpu", start: 6062, end: 6310, color:C.access },
    { row:3, name:"tat", start: 5831, end: 6046, color:C.access },
    { row:3, name:"rev", start: 5970, end: 6045, color:C.access },
    { row:3, name:"nef", start: 8797, end: 9417, color:C.access },

    // row 4 — LTRs
    { row:4, name:"5'-LTR", start: 1, end: 634, color:C.ltr },
    { row:4, name:"3'-LTR", start: 9407, end: GENOME_MAX, color:C.ltr }
  ];

  const anchors = [
    {id:"D1",pos:900},{id:"D2",pos:5100},{id:"D3",pos:5500},
    {id:"A1",pos:4800},{id:"A2",pos:5400},{id:"A3",pos:5700},
    {id:"A4",pos:5900},{id:"A5",pos:6000},{id:"A7",pos:8200}
  ];

  // Provide your own links via window.links, else demo:
  let links = Array.isArray(window.links) ? window.links : [
    {id:"L1", from:"D1", to:"A1", percent:6.2},
    {id:"L2", from:"D1", to:"A2", percent:4.8},
    {id:"L3", from:"D2", to:"A3", percent:2.9},
    {id:"L4", from:"D2", to:"A4", percent:3.5},
    {id:"L5", from:"D3", to:"A5", percent:1.7},
    {id:"L6", from:"D3", to:"A7", percent:2.1}
  ];

  // ========= SCAFFOLD =======================================================
  const W = 1200, H = 680, M = {t:30, r:24, b:80, l:80};
  const innerW = W - M.l - M.r, innerH = H - M.t - M.b;

  const svg = d3.select("#stage")
    .attr("viewBox", `0 0 ${W} ${H}`)
    .attr("preserveAspectRatio", "xMidYMid meet");

  const g = svg.append("g").attr("transform", `translate(${M.l},${M.t})`);

  // Scale clamped to [0, GENOME_MAX]
  const x = d3.scaleLinear()
    .domain([0, GENOME_MAX])
    .range([0, innerW])
    .clamp(true);

  // Axis in increments of 100
  const tickVals = d3.range(0, genomeMax + 1, 250);
  const xAxis = d3.axisBottom(x)
    .tickValues(tickVals)
    .tickFormat(d3.format("~d"))
    .tickSizeOuter(0);

  // --- Axis & grid ---
  const axisG = g.append("g").attr("transform",`translate(0,${baselineY})`);
  axisG.append("line")
    .attr("x1",0).attr("x2",innerW).attr("y1",0).attr("y2",0)
    .attr("stroke","#cdd3e1").attr("stroke-width",1.25);

  const grid = g.append("g");
  const xAxisG = g.append("g").attr("class","axis")
    .attr("transform", `translate(0,${baselineY})`);

  function drawAxis(zx){
    xAxisG.call(
      d3.axisBottom(zx).tickValues(tickVals).tickFormat(d3.format("~d")).tickSizeOuter(0)
    );
    const gridVals = tickVals.filter(d => d % 1000 === 0 || d === GENOME_MAX);
    const sel = grid.selectAll("line.v").data(gridVals, d=>d);
    sel.enter().append("line")
      .attr("class","v")
      .attr("y1", rowBand.range()[0]) // top of row area
      .attr("y2", arcAreaBottom)
      .attr("stroke","#98a2b3").attr("stroke-width",1).attr("opacity",.35)
      .merge(sel)
      .attr("x1", d=>zx(d)).attr("x2", d=>zx(d));
    sel.exit().remove();
  }
  drawAxis(x);

  // Row labels (optional)
  if (Object.keys(rowLabels).length) {
    g.append("g")
      .selectAll("text")
      .data(rows)
      .join("text")
        .attr("class","row-label")
        .attr("x", -12)
        .attr("y", d => rowBand(d) + rowBand.bandwidth()/2)
        .attr("text-anchor","end")
        .text(d => rowLabels[d] ?? `Row ${d}`);
  }

  // ========= FEATURES =======================================================
  const featuresG = g.append("g");

  function renderFeatures(zx){
    const byRow = d3.group(features, d => +d.row);
    const rowGroups = featuresG.selectAll("g.row").data(rows, d => d)
      .join(enter => enter.append("g").attr("class","row")
        .attr("data-row", d => d)
        .attr("transform", d => `translate(0, ${rowBand(d)})`)
      );

    rowGroups.each(function(rowNum){
      const group = d3.select(this);
      const feats = byRow.get(rowNum) || [];
      const rowH = rowBand.bandwidth();

      const sel = group.selectAll("g.feat").data(feats, d => d.name);
      const enter = sel.enter().append("g").attr("class","feat");
      enter.append("rect");
      enter.append("text").attr("dominant-baseline","middle");

      const merged = enter.merge(sel);
      merged.select("rect")
        .attr("x", d => zx(d.start))
        .attr("y", rowH*0.18)
        .attr("width", d => Math.max(1, zx(d.end) - zx(d.start)))
        .attr("height", rowH*0.64)
        .attr("fill", d => d.color);
      merged.select("text")
        .attr("x", d => zx(d.start) + (zx(d.end)-zx(d.start))/2)
        .attr("y", rowH*0.5)
        .attr("text-anchor","middle")
        .text(d => d.name);

      sel.exit().remove();
    });
  }
  renderFeatures(x);

  // ========= ANCHORS ========================================================
  const Amap = Object.fromEntries(anchors.map(a => [a.id, a]));
  const anchorG = g.append("g");
  const anchorNodes = anchorG.selectAll("g")
    .data(anchors)
    .join("g")
      .attr("transform", d => `translate(${x(d.pos)},${baselineY})`);
  anchorNodes.append("circle")
    .attr("r",4.5).attr("fill","#1f77b4").attr("stroke","#0b3a6f").attr("stroke-width",1.25);
  anchorNodes.append("text")
    .attr("y",12).attr("text-anchor","middle").text(d=>d.id).attr("fill","#dbe3f5").attr("font-size",12);

  // ========= ARCS (below axis) =============================================
  const maxPercent = d3.max(links, d => d.percent) || 1;
  const widthScale = d3.scaleSqrt().domain([0, maxPercent]).range([1.2, 14]);
  links = links.map(l => ({...l, label: `${l.from}➞${l.to} ${d3.format(".1f")(l.percent)}%`, strokeWidth: widthScale(l.percent)}));

  function arcPathDown(x0, x1, k=.33){
    const mid = (x0 + x1)/2;
    const span = Math.abs(x1 - x0);
    const h = Math.max(40, span * k);
    return `M${x0},${baselineY} Q${mid},${baselineY + h} ${x1},${baselineY}`;
  }

  const linksG = g.append("g").attr("class","links");
  const labelG = g.append("g").attr("class","labels");
  const defs = svg.append("defs");

  function renderLinks(zx){
    const pathSel = linksG.selectAll("path.link").data(links, d => d.id || `${d.from}-${d.to}`);
    pathSel.enter()
      .append("path")
      .attr("class","link")
      .attr("stroke", d => colorForDonor(d.from))
      .merge(pathSel)
      .attr("stroke-width", d => d.strokeWidth)
      .attr("d", d => {
        const x0 = zx(Amap[d.from].pos), x1 = zx(Amap[d.to].pos);
        return arcPathDown(x0,x1,.33);
      });
    pathSel.exit().remove();

    links.forEach((d,i) => {
      const pid = `arc-label-path-${i}`;
      let p = defs.select(`#${pid}`);
      if (p.empty()) p = defs.append("path").attr("id", pid);
      const x0 = zx(Amap[d.from].pos), x1 = zx(Amap[d.to].pos);
      p.attr("d", arcPathDown(x0,x1,.33));
    });

    const lblSel = labelG.selectAll("text.arc-label").data(links, d => d.id || `${d.from}-${d.to}`);
    const lblEnter = lblSel.enter().append("text").attr("class","arc-label").attr("dy", 14);
    lblEnter.append("textPath")
      .attr("href", (_,i)=>`#arc-label-path-${i}`)
      .attr("startOffset","50%")
      .attr("text-anchor","middle");
    lblEnter.merge(lblSel).select("textPath").text(d => d.label);
    lblSel.exit().remove();
  }
  function colorForDonor(donor){
    if (donor.startsWith("D1")) return "#4a90e2";
    if (donor.startsWith("D2")) return "#f5a623";
    if (donor.startsWith("D3")) return "#999999";
    return "#8aa7ff";
  }
  renderLinks(x);

  // ========= ZOOM (x-only, WITH CONSTRAIN) ==================================
  function onZoom(ev){
    const t = ev.transform;
    const zx = t.rescaleX(x);
    drawAxis(zx);
    renderFeatures(zx);
    anchorNodes.attr("transform", d => `translate(${zx(d.pos)},${baselineY})`);
    renderLinks(zx);
  }

  const zoom = d3.zoom()
    .scaleExtent([1, 20])
    .translateExtent([[0,0],[innerW, innerH]]) // ok to keep
    .constrain(t => {
      const k = t.k;
      // Clamp x so that 0 stays >= left edge and GENOME_MAX <= right edge
      const minX = innerW * (1 - k); // when fully panned right
      const maxX = 0;                // when fully panned left
      const clampedX = Math.max(minX, Math.min(maxX, t.x));
      return d3.zoomIdentity.translate(clampedX, 0).scale(k);
    })
    .on("zoom", onZoom);

  // prevent page scroll while wheel-zooming
  svg.node().addEventListener('wheel', e => e.preventDefault(), { passive:false });
  svg.call(zoom);
})();
</script>
```