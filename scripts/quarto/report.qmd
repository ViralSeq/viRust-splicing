---
title: "HIV Splicing Assay Report"
author: "Shuntai Zhou and Michael Clark @UNC-CH"
format:
  html:
    toc: true              # enable table of contents
    toc-location: left     # or "right"
    toc-float: true        # make TOC floating
    number-sections: true  # optional, for numbered headings
    code-fold: false       # don’t allow toggling
    code-summary: none
    code-line-numbers: false
    code-tools: false
    code-copy: false
    code-block-bg: false
    code-block-border-left: false
    theme: Superhero           # Superhero for dark theme. Materia or Cerualean for bright theme.
    smooth-scroll: true
    self-contained: true
    embed-resources: true
    fig-width: 12
    fig-height: 6
    page-layout: full
execute:
  echo: false              # hide all code by default
  warning: false
  message: false
params:
  version: "0.2.0"
  assay_type: "random-reverse"
  strain: "nl43"
  mismatch: 1
  file1: "nl43_r1.fastq.gz"
  file2: "nl43_r2.fastq.gz"
  summary_data_file: "output_summary.csv"
  splice_isoform_csv: "spliceforms_short.csv"
---

```{css}
table tr:nth-child(even) {
  background-color: #2b3b4b;
}
```

```{r setup, include=FALSE}
# allows the interactive shell has the same behavior as rendering
if (interactive()) {
  setwd(here::here("tests", "quarto"))  # or dirname(rstudioapi::getActiveDocumentContext()$path)
}
```

```{r}
library(tidyverse)
library(patchwork)
library(arsenal)
library(finalfit)
library(ggsci)
library(reticulate)
library(ggalluvial)
library(ggrepel)
library(ggnewscale)
library(scico)
library(jsonlite)
library(base64enc)
theme_set(theme_bw())
```


```{r}
if (!py_module_available("pandas")) {
  py_install("pandas")
} else {message("pandas installed")}

if (!py_module_available("plotly")) {
  py_install("plotly")
} else {message("plotly installed")}

```


```{r}

rustapp_version = params$version
assay_type =  params$assay_type
strain = params$strain
mismatch = params$mismatch
file1 = params$file1
file2 = params$file2
summary_data_path = params$summary_data_file
splice_isoform_csv = params$splice_isoform_csv

assay_type <- assay_type %>% toupper()
strain <- strain %>% toupper()
```



```{r}
# Read data

data <- read_csv(summary_data_path)

data <- data  %>%
  mutate(
    main_acceptor_after_d1 = case_when(
      str_detect(splice_category_2, "D1_A1") ~ "A1",
      str_detect(splice_category_2, "D1_A2") ~ "A2",
      str_detect(splice_category_2, "D1_A3") ~ "A3",
      str_detect(splice_category_2, "D1_A4") ~ "A4",
      str_detect(splice_category_2, "D1_A5") ~ "A5",
      str_detect(splice_category_2, "D1_A7") ~ "A7"
    ),
    main_acceptor_after_d1 = ifelse(spliced == "unspliced", "unspliced", main_acceptor_after_d1),
    main_acceptor_after_d1 = ff_label(main_acceptor_after_d1, "Main Acceptor After D1")
  )

# define alternative D1

list_GC_1 <- c("GCTGAAGCGCGCACG") # use GC after DIS
list_GC_2 <- c("CGCGCACGGCAAGAG") # use GC 5 base down first GC

list_GT_gag_AUG <- c("GAAGGAGAGAGATGG")

list_GT_gag_down <- c("GGTGCGAGAGCGTCG")

data <- data %>%
  mutate(
    D1_type_revised = ifelse((spliced == "spliced" & D1_type != "Alternative D1"), D1_type, NA)
  ) %>%
  mutate(
    D1_type_revised = case_when(
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_1)) ~ "GC 3 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_2)) ~ "GC 10 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_AUG)) ~ "GU downstream gag AUG",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_down)) ~ "GU further downstream in gag",
      (spliced == "spliced" & alternative_d1_used_common != "None") ~ "Others",
      T ~ D1_type_revised
    ),
  )
```


```{r}
# Here we merge the splice isoform information with the data
splice_form_data <- read_csv(splice_isoform_csv)
data <- data %>%
  left_join(splice_form_data, by = c("splice_category_2" = "SpliceForm"))

data = data %>% mutate(
    splice_cat2  = splice_cat2 %>%  ff_label("Splice isoforms (Shortened)"),
    splice_category_2 = splice_category_2 %>%  ff_label("Splice isoforms (Extended)"),
    size_class.x = size_class.x %>% ff_label("Size class")
  )

# get main donor after D1

data <- data %>%
  mutate(
    main_acceptor_after_d1 = case_when(
      str_detect(splice_category_2, "D1_A1") ~ "A1",
      str_detect(splice_category_2, "D1_A2") ~ "A2",
      str_detect(splice_category_2, "D1_A3") ~ "A3",
      str_detect(splice_category_2, "D1_A4") ~ "A4",
      str_detect(splice_category_2, "D1_A5") ~ "A5",
      str_detect(splice_category_2, "D1_A7") ~ "A7"
    ),
    main_acceptor_after_d1 = ifelse(spliced == "unspliced", "unspliced", main_acceptor_after_d1),
    main_acceptor_after_d1 = ff_label(main_acceptor_after_d1, "Main Acceptor After D1")
  )

# define alternative D1

list_GC_1 <- c("GCTGAAGCGCGCACG") # use GC after DIS
list_GC_2 <- c("CGCGCACGGCAAGAG") # use GC 5 base down first GC

list_GT_gag_AUG <- c("GAAGGAGAGAGATGG")

list_GT_gag_down <- c("GGTGCGAGAGCGTCG")

data <- data %>%
  mutate(
    D1_type_revised = ifelse((spliced == "spliced" & D1_type != "Alternative D1"), D1_type, NA)
  ) %>%
  mutate(
    D1_type_revised = case_when(
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_1)) ~ "GC 3 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GC_2)) ~ "GC 10 base downstream of DIS",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_AUG)) ~ "GU downstream gag AUG",
      (spliced == "spliced" & (alternative_d1_used_common %in% list_GT_gag_down)) ~ "GU further downstream in gag",
      (spliced == "spliced" & alternative_d1_used_common != "None") ~ "Others",
      T ~ D1_type_revised
    ),
    D1_type = ff_label(D1_type, "D1 types"),
    final_des = factor(final_des, levels = c("A3", "A4", "A5", "A7", "vif", "vpr", "Incomplete")),
    final_des = ff_label(final_des, "Final Destinations"),
    D1_type_revised = factor(
      D1_type_revised,
      levels = c(
        "GC 3 base downstream of DIS",
        "GC 10 base downstream of DIS",
        "D1",
        "D1prime",
        "GU downstream gag AUG",
        "GU further downstream in gag",
        "Others"
      )
    ),
    D1_type_revised = ff_label(D1_type_revised, "Detailed D1 types"),
  )

df_alluvium <- data %>% group_by(splice_cat2) %>%
  mutate(splice_category_count = n())

df_alluvium %>% filter(
  splice_cat2 != "Incomplete",
  splice_cat2 != "Unspliced") %>%
  select(c(15:26)) %>% select(-final_des, -step8c) %>% unique() -> df_alluvium_short

n <- df_alluvium_short$splice_category_count %>% sum()
cut_off_to_show = n * 0.03
df_alluvium_transformed <- df_alluvium_short %>% pivot_longer(cols = 1:8, names_to = "Steps")

```


```{r, echo=FALSE, results='asis'}
spliced_data = data %>% filter(spliced == "spliced") %>% count(splice_category_2)
total_spliced = spliced_data$n %>% sum()

splice_step_list = tibble(
  from = character(),
  to = character(),
  w = integer()
)

splice_step_list <- pmap_dfr(spliced_data, function(splice_category_2, n) {
  first_des <- substring(splice_category_2, 4, 5)
  return_tibble <- tibble(
    from = "D1",
    to = first_des,
    w = n
  )
  d2_pattern <- "D2b?_(A[0-9]+)"
  if (splice_category_2 %>% str_detect(d2_pattern)) {
    new_row <- tibble(
      from = "D2", to = str_match(splice_category_2, d2_pattern)[, 2], w = n
      )
    return_tibble <- return_tibble %>% bind_rows(new_row)
  }

  d3_pattern <- "D3_(A[0-9]+)"
  if (splice_category_2 %>% str_detect(d3_pattern)) {
    new_row <- tibble(
      from = "D3", to = str_match(splice_category_2, d3_pattern)[, 2], w = n
      )
    return_tibble <- return_tibble %>% bind_rows(new_row)
  }
  return(return_tibble)
})

link <- splice_step_list %>%
  group_by(from, to) %>%
  mutate(total = sum(w)) %>%
  ungroup() %>% select(-w) %>% unique() %>%
  mutate(w = total,
         total_spliced = total_spliced,
         percent = round(100 * w/total_spliced, 1)) %>%
  select(-total, -total_spliced) %>% arrange(from, to)

link <- toJSON(link, dataframe = "rows", auto_unbox=TRUE)
cat(sprintf('<script>window.links = %s;</script>', link))
```

Report generated on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Run settings

::: {.callout-important}
**Assay type:** `r assay_type`

**Reference type:** `r strain`

**Mismatch allowed:** `r mismatch`

**viRust-splicing app version:** `r rustapp_version`
:::

**Input File 1 path:** `r file1`

**Input File 2 path:** `r file2`

---

::: {.callout-note}
**Output Files:**

  1. ***TSV file:*** Splice isoform analysis for each sequence, one record per sequence. NOTE: sequences with low qualities are removed.

  2. ***CSF file:*** Summarized splice isoform analysis. One record per UMI family. NOTE: UMI family size less than 3 are not shown.

  3. ***HTML file:*** Splice isoform analysis and visualization.

:::

::: {.callout-tip}

This report can be generated again by running:

```bash
quarto render report.qmd --execute-params quarto_params.json
```

**DO NOT** render directly with report.qmd, params are required to properly process data.

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Overal Spliced vs. Unpliced

### Summary table

```{r}
# helper function for download

create_embedded_csv_link <- function(df) {
  tmp <-tempfile(fileext = ".csv")
  write_csv(df, tmp)
  b64 <- base64encode(tmp)
  download_link <- paste0(
    "data:text/csv;base64,",
    b64
  )
  invisible(file.remove(tmp))

  return(download_link)
}
```

```{r, results = 'asis'}
data  %>%
  mutate(spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown")))%>%
  tableby(~ spliced, data = .) -> splice_summary

splice_summary %>% summary()

data  %>%
  mutate(spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown"))) %>%
  count(spliced, sort = T) -> splice_summary

download_link <- create_embedded_csv_link(splice_summary)
```

[⬇️ Download this sumamry CSV for overall splice outcomes](`r download_link`){download="splice_summary.csv"}

### Percent spliced
```{r}
data %>%
  count(spliced, sort = TRUE)  %>%
  mutate(
    percent = 100 * n/ sum(n),
    spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown"))
  )  %>%
  ggplot(aes(x = 2, y = percent, fill = spliced)) +
  geom_col(color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = round(percent, 1)),
            position = position_stack(vjust = 0.5),
            color = "white") +
  scale_fill_nejm(name = "") +
  xlim(0.5, 2.5) +
  theme_void() +
  labs(title = "Percent Spliced",
       subtitle = "Including unknown") -> p1


data %>%
  count(spliced, sort = TRUE) %>%
  filter(spliced != "unknown") %>%
  mutate(
    percent = 100 * n/ sum(n),
    spliced = factor(spliced, levels = c("spliced", "unspliced", "unknown"))
  )  %>%
  ggplot(aes(x = 2, y = percent, fill = spliced)) +
  geom_col(color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = round(percent, 1)),
            position = position_stack(vjust = 0.5),
            color = "white") +
  scale_fill_nejm() +
  xlim(0.5, 2.5) +
  theme_void() +
  labs(title = "Percent Spliced",
       subtitle = "Excluding unknown") -> p2

p1 + p2 + theme(legend.position = "none")
```


::: {.callout-caution}
Unknown splice types can come from mismatches (sequencing errors), unrecognized patterns or non-HIV sequences. If greater than 5%, please check the raw TSV file for details.
:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>





## Size class analysis

```{r, results = 'asis'}
data %>% filter(spliced == "spliced") %>% tableby(~size_class.x, data = .) %>% summary()

size_class_summary <- data %>%
  filter(spliced == "spliced") %>%
  mutate(`Size class` = size_class.x) %>%
  count(`Size class`, sort = TRUE)

download_link <- create_embedded_csv_link(size_class_summary)
```

[⬇️ Download this sumamry CSV for Size class](`r download_link`){download="size_class_summary.csv"}


::: {.callout-caution}

- ***"Both"*** indicates that the splice isoform can be either 1.8kb or 4kb class. Post splicing sequences end before D4 (HXB2 6045). Splicing size class cannot be determined. Often see in RANDOM-REVERSE assay.

- ***"Unknown"*** indicates the post splicing sequence cannot be mapped to the reference genome. Size class cannot be interpreted. Mismatch and sequencing quality drop towards the end of sequences often cause this issue.

:::


<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>


## Splicing Event Map

Splice events from Dx to Ax, indicated in **Percentage among all SPLICED sequences by UMI family**.

```{=html}
<style>
  #splice_map{width:100%;margin:18px auto;padding:0 16px;}
  #splice_map .board{position:relative;background:#2b3b4b;border:1px solid #23314a;border-radius:14px;overflow:hidden}
  #splice_map svg{width:100%;height:680px;display:block}
  #splice_map .axis line,.axis path{stroke:#cdd3e1}
  #splice_map .tick text{fill:#cdd3e1;font-size:12px}
  #splice_map .row-label{fill:#cdd3e1;font-size:18px;dominant-baseline:middle}
  #splice_map .feat rect{rx:6; ry:6; stroke:#444d65ff; stroke-width:1}
  #splice_map .feat text{font-size:18; fill:#0b1220; font-weight:600; paint-order:stroke; stroke:#ffffff; stroke-width:3px; font-style: italic;}
  #splice_map .link{fill:none;stroke-opacity:.35;pointer-events:stroke}
  #splice_map .link:hover{stroke-opacity:.9}

  /* Hide arc labels until hover */
  #splice_map .arc-label{
    font:16px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    fill:#0b1220; paint-order:stroke; stroke:#ffffff; stroke-width:3px;
    pointer-events:none; opacity:0; transition:opacity .12s ease-in-out;
  }

  #splice_map .board, #splice_map svg{overscroll-behavior:contain;}

  /* Anchors */
  #splice_map .anchor-label{fill:#dbe3f5;font-size:14px;text-shadow:0 1px 0 #0b1220}
  #splice_map .anchor-stem{stroke:#cdd3e1;stroke-width:1;opacity:.65}

  /* Connectors */
  #splice_map .connector{fill:none;stroke:#ffffff88;stroke-width:2}

  /* Hint panel with Reset button inside */
  #splice_map .hint{
    position:absolute; top:8px; right:10px;
    background:rgba(15,23,42,.6); color:#e5efff;
    border:1px solid rgba(255,255,255,.18); border-radius:10px;
    padding:8px 12px;
    font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:8px;
    user-select:none;
  }
  #splice_map .hint .icon{font-size:14px}
  #splice_map .hint button{
    background:#eaf1ff; color:#0b1220;
    border:1px solid #2b4a7a; border-radius:6px;
    padding:4px 10px; font-size:12px; cursor:pointer;
  }
  #splice_map .hint button:hover{filter:brightness(.96);}
</style>

<div id="splice_map" class="wrap">
  <div class="board">
    <div class="hint" aria-hidden="true">
      <div style="display:flex;align-items:center;gap:6px;">
        <span class="icon">🖱️</span>
        <span>Scroll to zoom • Drag to pan ↔️</span>
      </div>
      <button id="resetZoomBtn" type="button">Reset Scale</button>
    </div>
    <svg id="stage"></svg>
  </div>
</div>

<script src="https://unpkg.com/d3@7"></script>
<script>
(function(){
  // ========= DATA ===========================================================
  const GENOME_MAX = 9719;
  const rowLabels = {1:"ORF1",2:"ORF2",3:"ORF3",4:"LTRs"};
  const C = {
    gag:"#6aa0e6", pol:"#d63b3b", env:"#f4be12",
    vif:"#94c973", ltr:"#aaaaaa",
    tat:"#448f71ff", rev:"#ec6fcfff",
    nef:"#9a0b79ff", vpu:"#c0d5f9ff", vpr:"#84a0d2ff"
  };
  const features = [
    {row:1,name:"gag",start:790,end:2292,color:C.gag},
    {row:1,name:"vif",start:5041,end:5619,color:C.vif},
    {row:1,name:"tat-2",start:8379,end:8424,color:C.tat},
    {row:1,name:"nef",start:8797,end:9417,color:C.nef},
    {row:2,name:"tat-1",start:5831,end:6045,color:C.tat},
    {row:2,name:"vpu",start:6062,end:6310,color:C.vpu},
    {row:2,name:"rev-2",start:8379,end:8653,color:C.rev},
    {row:3,name:"pol",start:2085,end:5096,color:C.pol},
    {row:3,name:"pro",start:2253,end:2550,color:C.pol},
    {row:3,name:"vpr",start:5559,end:5850,color:C.vpr},
    {row:3,name:"rev-1",start:5970,end:6045,color:C.rev},
    {row:3,name:"env",start:6225,end:8795,color:C.env},
    {row:1,name:"5'-LTR",start:1,end:634,color:C.ltr},
    {row:2,name:"3'-LTR",start:9407,end:GENOME_MAX,color:C.ltr}
  ];
  const anchors = [
    {id:"D1",pos:743},{id:"D2",pos:4962},{id:"D3",pos:5463},
    {id:"A1",pos:4913},{id:"A2",pos:5390},{id:"A3",pos:5777},
    {id:"A4",pos:5955},{id:"A5",pos:5977},{id:"A7",pos:8379},{id:"D4",pos:6045}
  ];
  let links = Array.isArray(window.links)?window.links:[
    {id:"L1",from:"D1",to:"A1",percent:6.2},
    {id:"L2",from:"D1",to:"A2",percent:4.8},
    {id:"L3",from:"D2",to:"A3",percent:2.9},
    {id:"L4",from:"D2",to:"A4",percent:3.5},
    {id:"L5",from:"D3",to:"A5",percent:1.7},
    {id:"L6",from:"D3",to:"A7",percent:2.1}
  ];
  links = links.map((l,i)=>({...l, uid:l.id||`L_${l.from}_${l.to}_${i}`}));

  // ========= SCAFFOLD =======================================================
  const W=1200,H=680,M={t:30,r:24,b:80,l:80};
  const innerW=W-M.l-M.r,innerH=H-M.t-M.b;
  const svg=d3.select("#stage").attr("viewBox",`0 0 ${W} ${H}`).attr("preserveAspectRatio","xMidYMid meet");
  const g=svg.append("g").attr("transform",`translate(${M.l},${M.t})`);
  const x=d3.scaleLinear().domain([0,GENOME_MAX]).range([0,innerW]).clamp(true);
  const rows=[...new Set(features.map(d=>+d.row))].sort((a,b)=>a-b);
  const rowBand=d3.scaleBand().domain(rows).range([0,innerH*0.55]).paddingInner(0.15).paddingOuter(0.05);
  const baselineY=Math.round(innerH*0.62);
  const tickVals=d3.range(0,GENOME_MAX+1,1000);
  const xAxisG=g.append("g").attr("class","axis").attr("transform",`translate(0,${baselineY})`);
  function drawAxis(zx){xAxisG.call(d3.axisBottom(zx).tickValues(tickVals).tickFormat(d3.format("~d")).tickSizeOuter(0));}
  drawAxis(x);

  // ========= FEATURES =======================================================
  const featuresG=g.append("g");
  function renderFeatures(zx){
    const byRow=d3.group(features,d=>+d.row);
    const rowGroups=featuresG.selectAll("g.row").data(rows,d=>d)
      .join(enter=>enter.append("g").attr("class","row").attr("data-row",d=>d)
        .attr("transform",d=>`translate(0,${rowBand(d)})`));
    rowGroups.each(function(rowNum){
      const group=d3.select(this);
      const feats=byRow.get(rowNum)||[];
      const rowH=rowBand.bandwidth();
      const sel=group.selectAll("g.feat").data(feats,d=>d.name);
      const enter=sel.enter().append("g").attr("class","feat");
      enter.append("rect"); enter.append("text").attr("dominant-baseline","middle");
      const merged=enter.merge(sel);
      merged.select("rect")
        .attr("x",d=>zx(d.start))
        .attr("y",rowH*0.18)
        .attr("width",d=>Math.max(1,zx(d.end)-zx(d.start)))
        .attr("height",rowH*0.64)
        .attr("fill",d=>d.color);
      merged.select("text")
        .attr("x",d=>zx(d.start)+(zx(d.end)-zx(d.start))/2)
        .attr("y",rowH*0.5)
        .attr("text-anchor","middle")
        .text(d=>d.name);
      sel.exit().remove();
    });
  }
  renderFeatures(x);

  // ========= CONNECTORS =====================================================
  const connectors=[{from:"tat-1",to:"tat-2"},{from:"rev-1",to:"rev-2"}];
  const connG=g.append("g").attr("class","connectors");
  function bridgePath(x1,y1,x2,y2,k=0.22){
    const midx=(x1+x2)/2,span=Math.hypot(x2-x1,y2-y1);
    const lift=Math.max(16,span*k)*-0.35,cy=(y1+y2)/2+lift;
    return `M${x1},${y1} Q${midx},${cy} ${x2},${y2}`;
  }
  function renderConnectors(zx){
    const data=connectors.map(c=>{
      const f=features.find(d=>d.name===c.from),t=features.find(d=>d.name===c.to);
      if(!f||!t)return null;
      return{path:bridgePath(zx(f.end),rowBand(f.row)+rowBand.bandwidth()/2,zx(t.start),rowBand(t.row)+rowBand.bandwidth()/2)};
    }).filter(Boolean);
    const sel=connG.selectAll("path.connector").data(data);
    sel.enter().append("path").attr("class","connector").merge(sel).attr("d",d=>d.path);
    sel.exit().remove();
  }
  renderConnectors(x);

  // ========= ANCHORS ========================================================
  const Amap=Object.fromEntries(anchors.map(a=>[a.id,a]));
  const anchorG=g.append("g");
  const anchorNodes=anchorG.selectAll("g").data(anchors).join("g")
    .attr("transform",d=>`translate(${x(d.pos)},${baselineY})`);
  anchorNodes.append("line").attr("class","anchor-stem").attr("y1",0).attr("y2",-10);
  anchorNodes.append("circle").attr("r",4.5).attr("fill","#1f77b4").attr("stroke","#0b3a6f").attr("stroke-width",1.25);
  anchorNodes.append("text").attr("class","anchor-label").attr("text-anchor","middle").attr("y",-14).text(d=>d.id);
  function layoutAnchorLabels(zx){
    const MIN_DX=26,STEP=12;let lastX=-Infinity,level=0;
    anchorNodes.select("text").attr("y",d=>{
      const xpx=zx(d.pos);if(xpx-lastX<MIN_DX)level++;else level=0;lastX=xpx;return-14-level*STEP;
    });
    anchorNodes.select("line.anchor-stem").attr("y2",function(){
      const ty=+d3.select(this.parentNode).select("text").attr("y");return ty+4;
    });
  }
  layoutAnchorLabels(x);

  // ========= LINKS ==========================================================
  const maxPercent=d3.max(links,d=>d.percent)||1;
  const widthScale=d3.scaleSqrt().domain([0,maxPercent]).range([1.2,14]);
  links=links.map(l=>({...l,label:`${l.from}➞${l.to} ${d3.format(".1f")(l.percent)}%`,strokeWidth:widthScale(l.percent)}));
  function arcPathDown(x0,x1,k=.33){
    const mid=(x0+x1)/2,span=Math.abs(x1-x0),h=Math.max(40,span*k);
    return`M${x0},${baselineY} Q${mid},${baselineY+h} ${x1},${baselineY}`;
  }
  const linksG=g.append("g").attr("class","links");
  const labelG=g.append("g").attr("class","labels");
  const defs=svg.append("defs");
  function renderLinks(zx){
    const pathSel=linksG.selectAll("path.link").data(links,d=>d.uid);
    const pathEnter=pathSel.enter().append("path").attr("class","link")
      .attr("stroke",d=>colorForDonor(d.from))
      .attr("data-uid",d=>d.uid)
      .on("mouseenter",function(e,d){d3.select(this).style("stroke-opacity",0.9);labelG.select(`#lbl-${d.uid}`).style("opacity",1);})
      .on("mouseleave",function(e,d){d3.select(this).style("stroke-opacity",0.35);labelG.select(`#lbl-${d.uid}`).style("opacity",0);});
    pathEnter.merge(pathSel)
      .attr("stroke-width",d=>d.strokeWidth)
      .attr("d",d=>{
        const x0=zx(Amap[d.from].pos),x1=zx(Amap[d.to].pos);return arcPathDown(x0,x1,.33);
      });
    pathSel.exit().remove();
    links.forEach(d=>{
      const pid=`arc-label-path-${d.uid}`;let p=defs.select(`#${pid}`);if(p.empty())p=defs.append("path").attr("id",pid);
      const x0=zx(Amap[d.from].pos),x1=zx(Amap[d.to].pos);p.attr("d",arcPathDown(x0,x1,.33));
    });
    const lblSel=labelG.selectAll("text.arc-label").data(links,d=>d.uid);
    const lblEnter=lblSel.enter().append("text").attr("class","arc-label").attr("dy",14).attr("id",d=>`lbl-${d.uid}`).style("opacity",0);
    lblEnter.append("textPath").attr("href",d=>`#arc-label-path-${d.uid}`).attr("startOffset","50%").attr("text-anchor","middle");
    lblEnter.merge(lblSel).select("textPath").text(d=>d.label);
    lblSel.exit().remove();
  }
  function colorForDonor(d){
    if(d.startsWith("D1"))return"#4a90e2";
    if(d.startsWith("D2"))return"#f5a623";
    if(d.startsWith("D3"))return"#999999";
    return"#8aa7ff";
  }
  renderLinks(x);

  // ========= ZOOM ===========================================================
  function onZoom(ev){
    const t=ev.transform,zx=t.rescaleX(x);
    drawAxis(zx);renderFeatures(zx);renderConnectors(zx);
    anchorNodes.attr("transform",d=>`translate(${zx(d.pos)},${baselineY})`);
    layoutAnchorLabels(zx);renderLinks(zx);
  }
  const zoom=d3.zoom().scaleExtent([1,20])
    .translateExtent([[0,0],[innerW,innerH]])
    .constrain(t=>{
      const k=t.k,minX=innerW*(1-k),maxX=0;
      const clampedX=Math.max(minX,Math.min(maxX,t.x));
      return d3.zoomIdentity.translate(clampedX,0).scale(k);
    }).on("zoom",onZoom);
  svg.node().addEventListener("wheel",e=>e.preventDefault(),{passive:false});
  svg.call(zoom);

  // ========= RESET BUTTON ===================================================
  document.getElementById("resetZoomBtn").addEventListener("click",()=>{
    svg.transition().duration(300).call(zoom.transform,d3.zoomIdentity);
  });
})();
</script>
```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## D1 types

```{r, results = 'asis'}

data %>% filter( spliced == "spliced" ) %>%
  tableby(~ D1_type, data = .) %>% summary(title = "D1 Type of splice isoforms")

data %>% filter( spliced == "spliced" ) %>%
  tableby(~ D1_type_revised, data = .) %>% summary(title = "D1 Type of splice isoforms (detailed types)")
```


<div style="margin-top: 4em;"></div>

```{r}
data %>% filter(
  spliced == "spliced"
) %>%
  count(D1_type_revised) %>%
  mutate(percent_d1_type = 100 * n/sum(n)) %>%
  ggplot(aes(x = D1_type_revised, y = percent_d1_type, fill = D1_type_revised)) +
  geom_col() +
  scale_fill_nejm(name = "D1 types") +
    labs(y = "Percentage", x = "Type of D1", title =
         "Types of D1 used") +
  scale_y_continuous(limits = c(0,110)) +
  theme(axis.text = element_blank()) +
  geom_text(aes(label = paste0(round(percent_d1_type), "%")), size = 3, vjust = -0.5)

```

::: {.callout-caution}

**Source of "Others" in D1 types:**

* Mismatched alternative D1

* Mismatched upstream acceptor sequences

* Potential PCR bias (PCR primer matching acceptor sequences)

* Other alternative D1 sites.

**If substantial amount of "Other D1" is observed, refer to TSV file for details.**

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splice Isoforms

### Splice Isoforms by Major D1 types

```{r, results = "asis"}
data %>% tableby( D1_type ~ splice_cat2 , data = .) %>% summary(
  title = "Splice isoforms by major D1 types"
)

summary_splice_form1 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type, splice_cat2) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type,
    values_from = n,
    values_fill = 0
  )

download_link <- create_embedded_csv_link(summary_splice_form1)
```

[⬇️ Download this sumamry CSV for Splice isoforms by major D1 types](`r download_link`){download="summary_splice_form1.csv"}


### Splice Isoforms by Detailed D1 types
```{r, results = 'asis'}
data %>% tableby( D1_type_revised ~ splice_cat2 , data = .) %>% summary(
  title = "Splice isoforms by detailed D1 types"
)

summary_splice_form2 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type_revised, splice_cat2) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type_revised,
    values_from = n,
    values_fill = 0
  )

download_link <- create_embedded_csv_link(summary_splice_form2)
```

[⬇️ Download this sumamry CSV for Splice isoforms by detailed D1 types](`r download_link`){download="summary_splice_form2.csv"}

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Acceptors After D1

### By Major D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type ~ main_acceptor_after_d1 , data = .) %>% summary(
  title = "Acceptor After D1 by major D1 types"
)

summary_first_acc1 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type, main_acceptor_after_d1) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type,
    values_from = n,
    values_fill = 0
  )


download_link <- create_embedded_csv_link(summary_first_acc1)
```

[⬇️ Download this sumamry CSV for First acceptor by major D1 types](`r download_link`){download="summary_first_acc1.csv"}

<div style="margin-top: 4em;"></div>

```{r}
data %>%
  filter(spliced == "spliced") %>%
  ggplot(
    aes(x = D1_type, fill = main_acceptor_after_d1)
  ) +
  geom_bar(position = "fill") +
  scale_fill_nejm(name = "Main Acceptor\nAfter D1") +
  labs(y = "Proportion",
       x = "D1 types")

```

### By Detailed D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type_revised ~ main_acceptor_after_d1 , data = .) %>% summary(
  title = "Acceptor After D1 by detailed D1 types"
)

summary_first_acc2 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type_revised, main_acceptor_after_d1) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type_revised,
    values_from = n,
    values_fill = 0
  )


download_link <- create_embedded_csv_link(summary_first_acc2)
```

[⬇️ Download this sumamry CSV for First acceptor by detailed D1 types](`r download_link`){download="summary_first_des2.csv"}


<div style="margin-top: 4em;"></div>

```{r}
data %>%
  filter(spliced == "spliced") %>%
  ggplot(
    aes(x = D1_type_revised, fill = main_acceptor_after_d1)
  ) +
  geom_bar(position = "fill") +
  scale_fill_nejm(name = "Main Acceptor\nAfter D1") +
  labs(y = "Proportion", x = "D1 types") +
  theme(axis.text.x = element_text(angle = 90))

```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Final Destination Summary

### By Major D1 Types

```{r, results = 'asis'}

data %>% tableby( D1_type ~ final_des , data = .) %>% summary(
  title = "Final desitinations by major D1 types"
)

summary_final_des1 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type, final_des) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type,
    values_from = n,
    values_fill = 0
  )


download_link <- create_embedded_csv_link(summary_final_des1)
```

[⬇️ Download this sumamry CSV for final destination by major D1 types](`r download_link`){download="summary_final_des1.csv"}


<div style="margin-top: 4em;"></div>

### By Detailed D1 types

```{r, results = 'asis'}
data %>% tableby( D1_type_revised ~ final_des , data = .) %>% summary(
  title = "Final desitinations by detailed D1 types"
)

summary_final_des2 <- data %>%
  filter(spliced == "spliced") %>%
  group_by(D1_type_revised, final_des) %>%
  summarize(
    n = n()
  ) %>% pivot_wider(
    names_from = D1_type_revised,
    values_from = n,
    values_fill = 0
  )


download_link <- create_embedded_csv_link(summary_final_des2)
```

[⬇️ Download this sumamry CSV for final destination by major D1 types](`r download_link`){download="summary_final_des2.csv"}


<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>


## Final Destinations by splice flows

What happened before each final destination.

::: {.callout-note}
"Others" in D1 type are excluded in this analysis.
:::

```{r}
summarize_splice_flow <- function(des) {
  final_des_data <- data %>% filter(
    spliced == "spliced",
    final_des == des,
    D1_type_revised != "Others"
  )

  header <- paste0("### ", des, "\n\n")

  if (nrow(final_des_data) == 0) {
    # Callout warning box
    warning_block <- paste0(
      "::: {.callout-warning}\n",
      "**Warning:** Final destination ", des, " has 0 reads.\n",
      ":::",
      "\n\n"
    )
    return(paste0(header, warning_block))
  } else {
    res <- tableby(~ splice_cat2, data = final_des_data)
    body <- paste(capture.output(print(summary(res), output = "markdown")), collapse = "\n")
    body <- paste0(body, "\n\n")
    return(paste0(header, body))
  }
}
```

```{r, results='asis'}
for (des in c("A3", "A4", "A5", "A7", "vif", "vpr")) {
  cat(summarize_splice_flow(des))
}
```

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splice Cascade Analysis

### Events after A1

Summarize the percent unspliced after A1 which is vif in the total reads that reach A1

```{r, results = 'asis'}
data %>% filter(
  spliced == "spliced",
  main_acceptor_after_d1 == "A1"
) %>% mutate(
  A1_fate = case_when(
    splice_category_2 %>% str_detect("D2_unknown") ~ "Sequence after D2/D2b unrecognized",
    splice_category_2 %>% str_detect("noD2b") ~ "Incomplete",
    splice_category_2 %>% str_detect("D2b_unknown") ~ "Sequence after D2/D2b unrecognized",
    splice_category_2 %>% str_detect("noD2") ~ "Incomplete",
    splice_category_2 %>% str_detect("D2b-unspliced") ~ "No splicing after A1/vif",
    TRUE ~ "Spliced at D2/D2b"
  ),
  A1_fate = factor(
    A1_fate,
    levels = c("Spliced at D2/D2b",
               "No splicing after A1/vif",
               "Incomplete",
               "Sequence after D2/D2b unrecognized")),
  A1_fate = A1_fate %>% ff_label("Splice Events After A1")
) -> data_A1

data_A1 %>% tableby(~ A1_fate, data = .) %>% summary()
```

::: {.callout-tip}

The category ***"Sequence after D2/D2b unrecognized"*** comes from:

1. mismatches due to sequencing error/quality drop.

2. other patterns.

3. short sequences.

:::

<div style="margin-top: 4em;"></div>

### Events after A2

Summarize the percent unspliced after A2 which is vif in the total reads that reach A2

**Splice outcomes at A2 by Upstream Acceptor**

```{r, results = 'asis'}
reach_A2 <- c(
  "D2_A2",
  "D2b_A2",
  "D1_A2"
) %>% paste(collapse = "|")

A2_incomplete <- c(
  "noD3",
  "D3_unknown"
) %>% paste(collapse = "|")

data %>% filter(
  spliced == "spliced",
  splice_category_2 %>% str_detect(reach_A2)
) %>% mutate(
  A2_fate = case_when(
    splice_category_2 %>% str_detect("noD3") ~ "Incomplete",
    splice_category_2 %>% str_detect("D3_unknown") ~ "Sequence after D3 too short/unrecognized",
    splice_category_2 %>% str_detect("D3-unspliced") ~ "No splicing after A2/vpr",
    TRUE ~ "Spliced at D3",
  ),
  A2_fate = factor(
    A2_fate,
    levels = c("Spliced at D3",
               "No splicing after A2/vpr",
               "Incomplete",
               "Sequence after D3 too short/unrecognized")),
  A2_fate = A2_fate %>% ff_label("Splice Events After A2")
) -> data_A2

data_A2 %>% mutate(
  upstream_event = ifelse(main_acceptor_after_d1 == "A1", "D1->A1->A2", "D1->A2")) %>%
  tableby(upstream_event ~ A2_fate, data = .) %>% summary()
```

::: {.callout-tip}

The category ***"Sequence after D3 too short/unrecognized" ***comes from:

1. mismatches due to sequencing error/quality drop.

2. short sequences, often in Random-Reverse assay.

It is possible the ***Incomplete*** group can also come from short reads in Random-Reverse assay.

:::

<div style="text-align: center; font-size: 1.5em; margin: 1em 0;">✦ ✦ ✦</div>

## Splicing Events Cascade Plots

Splice events cascade per unique UMI family.


```{python}
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px

# Load data
df = r.df_alluvium_transformed.dropna(subset=["value"])
# Build node list
nodes = list(df["value"].unique())
node_index = {ev:i for i,ev in enumerate(nodes)}

# Assign isoform colors
isoforms = df["splice_cat2"].unique()
palette = px.colors.qualitative.Set3
if len(isoforms) > len(palette):
    palette = palette * ((len(isoforms) // len(palette)) + 1)
colors = {iso: palette[i] for i, iso in enumerate(isoforms)}

# Build links with hover labels
sources, targets, values, link_labels, link_colors = [], [], [], [], []
for isoform, group in df.groupby("splice_cat2"):
    group = group.sort_values("Steps")
    events = group["value"].tolist()
    count = group["splice_category_count"].iloc[0]
    for i in range(len(events)-1):
        sources.append(node_index[events[i]])
        targets.append(node_index[events[i+1]])
        values.append(count)
        link_labels.append(f"Isoform: {isoform}<br>Count: {count}")
        link_colors.append(colors[isoform])

fig = go.Figure(go.Sankey(
    arrangement="snap",
    node=dict(label=nodes, pad=15, thickness=20),
    link=dict(
        source=sources,
        target=targets,
        value=values,
        color=link_colors,
        label=link_labels,
        hovertemplate="%{label}<extra></extra>"
    )
))

fig.update_layout(
    title_text="HIV Splicing Isoform Sankey (hover to see isoform + count)",
    font_size=12
)
```