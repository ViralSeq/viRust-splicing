use std::error::Error;
use std::fs;
use std::path::Path;
use std::process::Command;
use std::time::Instant;

use serde::Deserialize;
use serde::Serialize;

const QMD_TEMPLATE: &str = include_str!("../scripts/quarto/report.qmd");

pub fn check_r_installed() -> Result<(), Box<dyn Error>> {
    is_available("Rscript", &["--version"], "R")
}

pub fn check_quarto_installed() -> Result<(), Box<dyn Error>> {
    is_available("quarto", &["--version"], "Quarto")
}

pub fn check_python3_installed() -> Result<(), Box<dyn Error>> {
    is_available("python3", &["--version"], "Python 3")
}

pub fn check_node_installed() -> Result<(), Box<dyn Error>> {
    is_available("node", &["--version"], "Node.js")
}

pub fn check_r_packages() -> Result<(), Box<dyn Error>> {
    let check_env_script = include_str!("../scripts/R/check_env.R");

    let output = Command::new("Rscript")
        .arg("-e")
        .arg(check_env_script)
        .output()?;

    if output.status.success() {
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        Err(format!("R packages check failed: {}", stderr).into())
    }
}

pub fn r_summarize_data(tsv_path: &str, output_path: &str) -> Result<(), Box<dyn Error>> {
    let summarize_script = include_str!("../scripts/R/summarize_data.R");

    let output = Command::new("Rscript")
        .arg("-e")
        .arg(summarize_script)
        .arg(tsv_path)
        .arg(output_path)
        .output()?;

    if output.status.success() {
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        Err(format!("R summarize data failed: {}", stderr).into())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct QuartoParams<'a> {
    version: &'a str,
    assay_type: &'a str,
    strain: &'a str,
    mismatch: u8,
    file1: &'a str,
    file2: &'a str,
    summary_data_file: &'a str,
}

pub fn run_quarto_report(
    assay_type: &str,
    strain: &str,
    mismatch: &u8,
    file1: &str,
    file2: &str,
    summary_data_file: &str, // File name of the summary CSV generated by R. Notice it needs to be in the output directory, aka. same as the .QMD file.
    output_dir: &Path,
) -> std::io::Result<()> {
    // Ensure output directory exists
    fs::create_dir_all(output_dir)?;
    // Write the QMD template to a file in the output directory
    let qmd = output_dir.join("report.qmd");
    fs::write(&qmd, QMD_TEMPLATE)?;

    let version = env!("CARGO_PKG_VERSION"); // compile-time version
    let start = Instant::now();

    let splice_isoform_csv = output_dir.join("spliceforms_short.csv");

    write_reference_csv(&splice_isoform_csv)?;

    let mismatch = *mismatch;

    let params = QuartoParams {
        version,
        assay_type,
        strain,
        mismatch,
        file1,
        file2,
        summary_data_file,
    };

    let json_params = serde_json::to_string(&params)?;

    fs::write(output_dir.join("quarto_params.json"), &json_params)?;

    #[cfg(debug_assertions)]
    dbg!(&json_params);

    // Run Quarto
    let output = Command::new("quarto")
        .arg("render")
        .arg(qmd)
        .arg("--execute-params")
        .arg(output_dir.join("quarto_params.json"))
        .output()?;

    let elapsed = start.elapsed();
    println!("✅ Report generated in {:.2?}", elapsed);

    if !output.status.success() {
        eprintln!("⚠️ Quarto render failed.");
        eprintln!("--- stdout ---");
        eprintln!("{}", String::from_utf8_lossy(&output.stdout));
        eprintln!("--- stderr ---");
        eprintln!("{}", String::from_utf8_lossy(&output.stderr));
        Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "Quarto render command failed",
        ))
    } else {
        Ok(())
    }
}

pub fn write_reference_csv(spliceform_file: &Path) -> std::io::Result<()> {
    let reference_csv = include_str!("../data/spliceforms_short.csv");
    std::fs::write(spliceform_file, reference_csv)
}

fn is_available(cmd: &str, args: &[&str], program: &str) -> Result<(), Box<dyn Error>> {
    Command::new(cmd)
        .args(args)
        .output()
        .map(|output| {
            if output.status.success() {
                Ok(())
            } else {
                Err(format!("{} command failed to execute properly.", cmd).into())
            }
        })
        .unwrap_or_else(|_| {
            Err(format!("{} is not installed or not found in PATH.", program).into())
        })
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn test_check_r_installed() {
        assert!(check_r_installed().is_ok());
    }

    #[test]
    fn test_check_quarto_installed() {
        assert!(check_quarto_installed().is_ok());
    }

    #[test]
    fn test_check_python3_installed() {
        assert!(check_python3_installed().is_ok());
    }

    #[test]
    fn test_check_r_packages() {
        assert!(check_r_packages().is_ok());
    }

    #[test]
    fn test_generate_html_report() {
        let assay_type = "random-reverse";
        let strain = "test-strain";
        let mismatch = 1;
        let file1 = "r1.fastq.gz";
        let file2 = "r2.fastq.gz";
        let summary_data_path = "output_summary.csv";
        let output_dir = "tests/quarto/";

        let result = run_quarto_report(
            assay_type,
            strain,
            &mismatch,
            file1,
            file2,
            summary_data_path,
            &std::path::Path::new(output_dir),
        );

        assert!(result.is_ok());
    }
}
