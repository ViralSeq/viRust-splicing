use std::error::Error;
use std::fs;
use std::path::Path;
use std::process::Command;
use std::time::Instant;

use serde::Deserialize;
use serde::Serialize;

/// Quarto report template
const QMD_TEMPLATE: &str = include_str!("../scripts/quarto/report.qmd");

/// Check if R, Quarto, and Python3 are installed, necessary for report generation.
pub fn check_r_installed() -> Result<(), Box<dyn Error>> {
    is_available("Rscript", &["--version"], "R")
}

pub fn check_quarto_installed() -> Result<(), Box<dyn Error>> {
    is_available("quarto", &["--version"], "Quarto")
}

pub fn check_python3_installed() -> Result<(), Box<dyn Error>> {
    is_available("python3", &["--version"], "Python 3")
}

/// check and install required R packages
/// This function runs an R script that checks for required packages and installs any that are missing.
/// The R script is included as a string literal from an external file.
pub fn check_r_packages() -> Result<(), Box<dyn Error>> {
    let check_env_script = include_str!("../scripts/R/check_env.R");

    let output = Command::new("Rscript")
        .arg("-e")
        .arg(check_env_script)
        .output()?;

    if output.status.success() {
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        Err(format!("R packages check failed: {}", stderr).into())
    }
}

/// Run the R script to summarize data
/// This function runs an R script that summarizes data from a TSV file and outputs the results to a specified path.
/// The R script is included as a string literal from an external file.

pub fn r_summarize_data(tsv_path: &str, output_path: &str) -> Result<(), Box<dyn Error>> {
    let summarize_script = include_str!("../scripts/R/summarize_data.R");

    let output = Command::new("Rscript")
        .arg("-e")
        .arg(summarize_script)
        .arg(tsv_path)
        .arg(output_path)
        .output()?;

    if output.status.success() {
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        Err(format!("R summarize data failed: {}", stderr).into())
    }
}

/// Parameters to pass to the Quarto report
/// Struct fields explained:
/// - version: Version of viRust-splicing generating the report.
/// - assay_type: Type of assay (e.g., "random-reverse", "Kmer", etc.)
/// - strain: Reference strain name provided by the user.
/// - mismatch: Allowed mismatches in alignment.
/// - file1: Name of the first FASTQ file (R1).
/// - file2: Name of the second FASTQ file (R2).
/// - summary_data_file: Path to the summary CSV file generated by the R script.

#[derive(Debug, Serialize, Deserialize)]
pub struct QuartoParams<'a> {
    version: &'a str,
    assay_type: &'a str,
    strain: &'a str,
    mismatch: u8,
    file1: &'a str,
    file2: &'a str,
    summary_data_file: &'a str,
}

/// Generate HTML report using Quarto
/// This function generates an HTML report using Quarto, based on the provided parameters and a summary CSV file.
/// It creates a Quarto markdown file from a template, writes the parameters to a JSON file, and then runs the Quarto command to render the report.
/// The report is saved in the specified output directory.
/// # Arguments
/// * `assay_type` - Type of assay (e.g., "random-reverse", "Kmer", etc.)
/// * `strain` - Reference strain name provided by the user.
/// * `mismatch` - Allowed mismatches in alignment.
/// * `file1` - Name of the first FASTQ file (R1).
/// * `file2` - Name of the second FASTQ file (R2).
/// * `summary_data_file` - Path to the summary CSV file generated by the R script.
/// * `output_dir` - Directory where the report and related files will be saved.
/// # Returns
/// * `std::io::Result<()>` - Result indicating success or failure of the report generation process.

pub fn run_quarto_report(
    assay_type: &str,
    strain: &str,
    mismatch: &u8,
    file1: &str,
    file2: &str,
    summary_data_file: &str, // File name of the summary CSV generated by R. Notice it needs to be in the output directory, aka. same as the .QMD file.
    output_dir: &Path,
) -> std::io::Result<()> {
    // Ensure output directory exists
    fs::create_dir_all(output_dir)?;
    // Write the QMD template to a file in the output directory
    let qmd = output_dir.join("report.qmd");
    fs::write(&qmd, QMD_TEMPLATE)?;

    let version = env!("CARGO_PKG_VERSION"); // compile-time version
    let start = Instant::now();

    let splice_isoform_csv = output_dir.join("spliceforms_short.csv");

    write_reference_csv(&splice_isoform_csv)?;

    let mismatch = *mismatch;

    let params = QuartoParams {
        version,
        assay_type,
        strain,
        mismatch,
        file1,
        file2,
        summary_data_file,
    };

    let json_params = serde_json::to_string(&params)?;

    fs::write(output_dir.join("quarto_params.json"), &json_params)?;

    #[cfg(debug_assertions)]
    dbg!(&json_params);

    // Run Quarto
    let output = Command::new("quarto")
        .arg("render")
        .arg(qmd)
        .arg("--execute-params")
        .arg(output_dir.join("quarto_params.json"))
        .output()?;

    let elapsed = start.elapsed();
    println!("✅ Report generated in {:.2?}", elapsed);

    if !output.status.success() {
        eprintln!("⚠️ Quarto render failed.");
        eprintln!("--- stdout ---");
        eprintln!("{}", String::from_utf8_lossy(&output.stdout));
        eprintln!("--- stderr ---");
        eprintln!("{}", String::from_utf8_lossy(&output.stderr));
        Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "Quarto render command failed",
        ))
    } else {
        Ok(())
    }
}

/// Write the reference spliceform CSV to a specified file path.
/// This function writes a predefined CSV string (included in the binary) to the specified file path.
/// The CSV contains reference spliceform data used in the report generation.

pub fn write_reference_csv(spliceform_file: &Path) -> std::io::Result<()> {
    let reference_csv = include_str!("../data/spliceforms_short.csv");
    std::fs::write(spliceform_file, reference_csv)
}

/// Check if a command is available in the system PATH.
/// This function attempts to run a command with specified arguments and checks if it executes successfully.

fn is_available(cmd: &str, args: &[&str], program: &str) -> Result<(), Box<dyn Error>> {
    Command::new(cmd)
        .args(args)
        .output()
        .map(|output| {
            if output.status.success() {
                Ok(())
            } else {
                Err(format!("{} command failed to execute properly.", cmd).into())
            }
        })
        .unwrap_or_else(|_| {
            Err(format!("{} is not installed or not found in PATH.", program).into())
        })
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn test_check_r_installed() {
        assert!(check_r_installed().is_ok());
    }

    #[test]
    fn test_check_quarto_installed() {
        assert!(check_quarto_installed().is_ok());
    }

    #[test]
    fn test_check_python3_installed() {
        assert!(check_python3_installed().is_ok());
    }

    #[test]
    fn test_check_r_packages() {
        assert!(check_r_packages().is_ok());
    }

    #[test]
    fn test_generate_html_report() {
        let assay_type = "random-reverse";
        let strain = "test-strain";
        let mismatch = 1;
        let file1 = "r1.fastq.gz";
        let file2 = "r2.fastq.gz";
        let summary_data_path = "output_summary.csv";
        let output_dir = "tests/quarto/";

        let result = run_quarto_report(
            assay_type,
            strain,
            &mismatch,
            file1,
            file2,
            summary_data_path,
            &std::path::Path::new(output_dir),
        );

        assert!(result.is_ok());
    }
}
